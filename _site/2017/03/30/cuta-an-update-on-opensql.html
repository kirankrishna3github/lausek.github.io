<p><strong>Note:</strong> All these things require ABAP 7.40 SP05 or higher!</p>
<p>The new OpenSQL implements stuff, web developers already know as <strong>S-Q-L</strong>, but anyway... With these things finally available, we can do all the neat data processings. Such fun. Much wow. Trust me, it's true.</p>
<h3>Don't fear the new syntax</h3>
<p>As my colleagues have noticed that I am using <code>@</code>-signs in my SQL statements and commas in the field list, they all got very worried. Yeah, it looks strange at first glance but once you know what it does...</p>
<p>Short answer: <strong><em>nothing</em></strong></p>
<p>There really is no special functionality behind. You just have to prefix every program-intern variable with an <code>at</code>, so the query parser doesn't get confused about its own data. Using commas to separate the selected columns already is common practice in nearly every other structured query language.</p>
<h3>Making use of declaration operators</h3>
<p>Declaring structures by hand is lame, time-consuming and sooooo unnecessary. Everything is there. Compiler? How about just take it by yourself?!</p>
<p>This is just a very basic code snippet that fetches customers from company code 3000 with their names before 7.4:</p>
<pre><code class="language-abap">TYPES:
BEGIN OF t_data_s,
    bukrs TYPE bukrs,
    kunnr TYPE kunnr,
    name1 TYPE name1,
    name2 TYPE name2,
END OF t_data_s.
DATA i_data TYPE STANDARD TABLE OF t_data_s WITH KEY bukrs kunnr.

SELECT b~bukrs b~kunnr a~name1 a~name2
  FROM knb1 AS b
  JOIN kna1 AS a
    ON a~kunnr = b~kunnr
  INTO TABLE i_data
 WHERE b~bukrs = '3000'.
</code></pre>
<p>Now look at that one. Beautiful.</p>
<pre><code class="language-abap">SELECT b~bukrs, b~kunnr, a~name1, a~name2
  FROM knb1 AS b
  JOIN kna1 AS a
    ON a~kunnr = b~kunnr
  WHERE b~bukrs = '3000'
  INTO TABLE @DATA(i_data).
</code></pre>
<p>But what if we want to move the value of <code>name1</code> into <code>fullname</code> instead of <code>name1</code>? We would have to declare another column named <code>fullname</code>, alias <code>name1</code> and extend <code>INTO TABLE</code> with <code>CORRESPONDING FIELDS OF</code>. That's too much for me. We just do it this way:</p>
<pre><code class="language-abap">SELECT b~bukrs, b~kunnr, a~name1 AS fullname, a~name2
  FROM knb1 AS b
  JOIN kna1 AS a
    ON a~kunnr = b~kunnr
  WHERE b~bukrs = '3000'
  INTO TABLE @DATA(i_data).

&quot; i_data is typed! You can access each component individually!
</code></pre>
<p>You see: one <code>AS</code> is enough to nickname a field.</p>
<h3>More precise selection</h3>
<p>The only thing I want to mention here is that you can now select <code>*</code> from a specific table instead of just <strong><em>ALL</em></strong>.</p>
<p>Before 7.4:</p>
<pre><code class="language-abap">SELECT *
    FROM table1
    JOIN table2
...
</code></pre>
<blockquote>
<p>Little guessing game: What could be the output of above code?</p>
<ul>
<li>All fields from table1</li>
<li>All fields from table2</li>
<li>All fields from all tables</li>
</ul>
</blockquote>
<p>Answer: &quot;ERROR: Too many fields specified&quot; because all fields are specified even though nobody wants to select everything from every table... Now:</p>
<pre><code class="language-abap">&quot; Pfewww. Gotcha!
SELECT table1~*
    FROM table1
    JOIN table2
...
</code></pre>
<p>I think there should be no doubt about which one is better, right?</p>
<h3>About expressions</h3>
<p>Computing results wasn't really possible in the old OpenSQL. I can't even find any computation in my code at all. Here are only a few snippets of the new possibilities.</p>
<p>Calculating..</p>
<pre><code class="language-abap">SELECT num1 + num2, num1 - num2, num1 * num2, num1 / num2 ...
</code></pre>
<p>Concatenating...</p>
<pre><code class="language-abap">SELECT name1 &amp;&amp; name2 ...
</code></pre>
<p>Calling inbuilt functions...</p>
<pre><code class="language-abap">SELECT abs( num ), ceil( num ), floor( num ) ...
</code></pre>
<p>Casting (pretty useless atm as only float and dec are allowed)...</p>
<pre><code class="language-abap">SELECT cast( dmbtr AS fltp ) ...
</code></pre>
<p>Coalesce...</p>
<pre><code class="language-abap">SELECT coalesce( num1, num2 ), coalesce( NULL, num2 ) ...
</code></pre>
<h3>The infamous <code>CASE</code></h3>
<p>We can finally select stuff based on a condition inside queries ðŸŽ‰. There are two possible forms:</p>
<ul>
<li>
<p>Like <code>COND</code> or <code>IF ... ELSEIF ... ELSE</code>:</p>
<pre><code class="language-abap">CASE &quot; nothing in this place
    WHEN state = 1 THEN ...
    WHEN state = 2 THEN ...
    ELSE ...
END
</code></pre>
</li>
<li>
<p>Like <code>CASE</code> or <code>SWITCH</code>:</p>
<pre><code class="language-abap">CASE state
    WHEN 1 THEN ...
    WHEN 2 THEN ...
    ELSE ...
END
</code></pre>
</li>
</ul>
<p>You are free to replace <em>...</em> with a type compatible column or another SQL expression.</p>
<h3>Let's get you creative!</h3>
<p>If you ever wondered how to correctly (in terms of debit and credit) sum up <code>BSID</code> without any looping - there you go:</p>
<pre><code class="language-abap">SELECT SUM( CASE shkzg
                WHEN 'H' THEN dmbtr
                WHEN 'S' THEN dmbtr * -1 &quot; negate for subtraction
            END )
    FROM bsid
    WHERE bukrs = @&lt;bukrs&gt;
    AND kunnr = @&lt;kunnr&gt;
    AND rebzg = @&lt;belnr&gt;
    INTO @DATA(w_payed).
</code></pre>
<p>Wanna join names without <code>CONCATENATE</code>? What do you think about this?</p>
<pre><code class="language-abap">SELECT SINGLE name1 &amp;&amp; name2 AS fullname,
              name1 &amp;&amp; 'y' AS nick
    FROM kna1
    INTO @DATA(wa_somebody).

WRITE: |Somebodys name is &quot;{ wa_somebody-fullname }&quot; but his friends call him &quot;{ wa_somebody-nick }&quot;|.
&quot; =&gt; Somebodys name is &quot;Bob Bobington&quot; but his friends call him &quot;Boby&quot;
</code></pre>
